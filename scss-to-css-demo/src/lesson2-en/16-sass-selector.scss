@use "sass:selector";

/*
selector.is-superselector($super, $sub)
is-superselector($super, $sub) //=> boolean 
Returns whether the selector $super matches all the elements 
that the selector $sub matches.

Still returns true even if $super matches more elements than $sub.
The $super and $sub selectors may contain placeholder selectors, 
but not parent selectors.
简言之, $super是否全包含$sub
*/
@debug selector.is-superselector("a", "a.disabled"); // true
@debug selector.is-superselector("a.disabled", "a"); // false
@debug selector.is-superselector("a", "sidebar a"); // true
@debug selector.is-superselector("sidebar a", "a"); // false
@debug selector.is-superselector("a", "a"); // true

/*
selector.append($selectors...)
selector-append($selectors...) //=> selector 
Combines $selectors without descendant combinators—that is, without whitespace between them.

If any selector in $selectors is a selector list, each complex selector is combined separately.

The $selectors may contain placeholder selectors, but not parent selectors.
简言之, 将前后选择器作为字符串, 简单连接起来. 某个选择器是选择器列表时, 则执行逐个连接
*/
@debug selector.append("a", ".disabled"); // a.disabled
@debug selector.append(".accordion", "__copy"); // .accordion__copy
@debug selector.append(".accordion", "__copy, __image"); // .accordion__copy, .accordion__image
@debug selector.append("head-1,head-2", "a b c,.a1.b1", "-middle", ".tail-1,.tail-2"); //共2*2*1*2=8个

/*
selector.nest($selectors...)
selector-nest($selectors...) //=> selector 
Combines $selectors as though they were nested within one 
another in the stylesheet.

The $selectors may contain placeholder selectors. Unlike other 
selector functions, all of them except the first may also contain parent selectors.
简言之, 各选择器依次以上下级关系连接, 中间以空格隔开, 以示祖孙关系
*/
@debug selector.nest("ul", "li"); // ul li
@debug selector.nest(".alert, .warning", "p"); // .alert p, .warning p
@debug selector.nest(".alert", "&:hover"); // .alert:hover
@debug selector.nest(".accordion", "&__copy"); // .accordion__copy

/*
selector.parse($selector)
selector-parse($selector) //=> selector 
Returns $selector in the selector value format.
*/
@debug selector.parse(".main aside:hover, .sidebar p");
//虽然不带引号语法上也允许, 但是无法使用一些符号,例如 . :
@debug selector.parse(main aside-hover-sidebar-p sec);

/*
selector.replace($selector, $original, $replacement)
selector-replace($selector, $original, $replacement) //=> selector 
Returns a copy of $selector with all instances of $original 
replaced by $replacement.

This uses the @extend rule’s intelligent unification to make sure 
$replacement is seamlessly integrated into $selector. If $selector 
doesn’t contain $original, returns it as-is.

The $selector, $original, and $replacement selectors may contain 
placeholder selectors, but not parent selectors.
*/
@debug selector.replace("a.disabled", "a", ".link"); // .link.disabled (顺序已调整)
@debug selector.replace("a.disabled", "h1", "h2"); // a.disabled
@debug selector.replace(".guide .info", ".info", ".content nav.sidebar");
// .guide .content nav.sidebar, .content .guide nav.sidebar

/*
selector.unify($selector1, $selector2)
selector-unify($selector1, $selector2) //=> selector | null 
Returns a selector that matches only elements matched by both 
$selector1 and $selector2.

Returns null if $selector1 and $selector2 don’t match any of 
the same elements, or if there’s no selector that can express their overlap.

Like selectors generated by the @extend rule, the returned selector 
isn’t guaranteed to match all the elements matched by both $selector1 
and $selector2 if they’re both complex selectors.
简言之, 返回两个选择器的交集选择器
*/
@debug selector.unify("a", ".disabled"); // a.disabled
@debug selector.unify("a.disabled", "a.outgoing"); // a.disabled.outgoing
@debug selector.unify("a", "h1"); // null
@debug selector.unify(".warning a", "main a"); // .warning main a, main .warning a

/*
selector.simple-selectors($selector)
simple-selectors($selector) //=> list 
Returns a list of simple selectors in $selector.

The $selector must be a single string that contains a compound 
selector. This means it may not contain combinators (including spaces) or commas.

The returned list is comma-separated, and the simple selectors are unquoted strings.
*/
@debug selector.simple-selectors("a.disabled"); // a, .disabled
@debug selector.simple-selectors("main.blog:after"); // main, .blog, :after
