@use "sass:meta";
@use "sass:math";
@use "sass:list";
@use "lib/sys-function" as sys;
//@use "lib/code" as CD; //仅作为与meta.laod-css对比而开放.
/*
meta.load-css($url, $with: null) 
使用场景类似于mixin, $with参数可配置被加载文件(模块)的变量(without $), 以输出期望css属性值
第二次加载被忽略, 连同其提供的$with配置.
不同于@use "<filepath>":
	1. 不引入任何成员
	2. 可在任何层级调用
	3. url可使用变量,甚至夹杂插值
	这是一种临时引入样式设置, 而不惊动全局的做法.
	
	总结:
		1. 如果scss库的样式块, 用到模块内部的变量作为条件, 应考虑使用meta.load-css, 
		配合$with设置, 可惜只能设置第一次;
		2. 如果scss库的样式块, 带参数, 该参数可能作为条件, 也可能作为内部值, 应考虑
		使用@use + @include <mixin-name> ,但应注意@use后,mixin-name应前缀命名空间
		3. 如果scss库, 已经@use, 局部地区又需要 meta.load-css, 则此时无法对其配置.
		所以, 最佳体验, 应该是 准备作为meta.load-css使用的模块, 不应有mixin; 反之亦然.
		4. 虽然名字是 load-css, 但是指定路径必须采用scss风格, 而不是 css 的 @import风格. 
		虽然两者有重叠.(The $url parameter should be a string containing a URL 
		like you’d pass to the @use rule. It shouldn’t be a CSS url()!)
*/
.minok.dark {
	text-align: center;
	.hollow {
		&:after {
			content: "no no no";
			//如果已经使用@use ,这里也会被阻止而报错
			@include meta.load-css("lib/code", $with: (border-contrast: true));
		}
	}
	margin: 15px;
}
/*
采用mixin形式,仅作为与meta.laod-css对比而开放.
*/
// .nlytise.light {
// 	text-align: center;
// 	.hollow {
// 		&:after {
// 			content: "no no no";
// 			//@include meta.load-css("lib/code"); //第二次引入,如果带$with配置, 则引发错误
// 			@include CD.another-code;
// 		}
// 	}
// 	margin: 15px;
// }

/*
meta.calc-args($calc) //=> list 

Returns the arguments for the given calculation.
If an argument is a number or a nested calculation, it’s returned 
as that type. Otherwise, it’s returned as an unquoted string.
注意: math.xxx()方法, 不被认为是calculation 
*/
@debug meta.calc-args(calc(100px + 10%)); // unquote("100px + 10%")
@debug meta.calc-args(clamp(50px, var(--width), 1000px)); // 50px, unquote("var(--width)"), 1000px
//@debug meta.calc-args(math.clamp(50px, var(--width), 1000px)); //这样反而会报var的错
//@debug meta.calc-args(math.ceil(math.random(180))); //Error: $calc: 177 is not a calculation.
@debug meta.calc-args(calc(304.8px + 48%));
@debug meta.calc-args(min(100px, calc(1rem + 10%), 73pt, clamp(50px, var(--width), 1000px)));

@debug meta.calc-name(clamp(50px, var(--width), 1000px)); //clamp
@debug meta.calc-name(min(100px, calc(1rem + 10%), 73pt, clamp(50px, var(--width), 1000px)));

/*
meta.call($funciton,$args...)应和meta.get-function($name,$css:false,$module:null)配合使用.
注意@use进来的function, 应正确设置$module参数
$css标志该函数的来源,是否是普通的css函数. 如果是, scss将对找不到的函数保持沉默, 而不是引发错误
使用示例: 09-values.scss 搜索 remove-where方法
*/

/*
meta.content-exists()
content-exists() //=> boolean 

Returns whether the current mixin was passed a @content block.
Throws an error if called outside of a mixin.
*/
@mixin mix-need-content {
	text-align: center;
	@if not meta.content-exists() {
		@warn "you'd better call me with a real content.";
	}
	@content;
}
.gleese {
	@include mix-need-content {
		&:hover {
			color: red;
		}
	}
}

/*
meta.feature-exists($feature)
feature-exists($feature) //=> boolean 
Returns whether the current Sass implementation supports $feature.
$feature可以是;global-variable-shadowing extend-selector-pseudoclass units-level3
at-error custom-property
下面是结合meta.get-function,meta.call方法的示例.
*/
$fun: meta.get-function("feature-supported", $module: "sys", $css: false); //$css:false为默认可以省略
.temp {
	//不带命名空间的调用,sass并不能察觉错误,以为是原生的css方法
	// $results: feature-supported();
	// supported: list.nth($results, 1);  //sass一直以为能得到一个单元素的列表
	// unsupported: list.nth($results, 2); //到此才会提示索引2非法

	//按照get-function -> call(fun-name)的步骤, sass能按部就班查询函数, 及时发现错误
	$results: meta.call($fun);
	supported: list.nth($results, 1); //sass一直以为能得到一个单元素的列表
	unsupported: list.nth($results, 2); //到此才会提示索引2非法
}

/*
meta.function-exists($name, $module: null)
function-exists($name) //=> boolean 

Returns whether a function named $name is defined, either as a 
built-in function or a user-defined function.

If $module is passed, this also checks the module named $module 
for the function definition. $module must be a string matching 
the namespace of a [@use rule][] in the current file.
*/
@debug meta.function-exists("div", "math"); // true
@debug meta.function-exists("scale-color"); // true
@debug meta.function-exists("add"); // false

@function add($num1, $num2) {
	@return $num1 + $num2;
}
@debug meta.function-exists("add"); // true
@debug meta.function-exists("feature-supported"); //false
@debug meta.function-exists("feature-supported", sys); //true

/*
meta.variable-exists($name)
variable-exists($name) //=> boolean 
Returns whether a variable named $name (without the $) exists in the current scope.

meta.global-variable-exists($name, $module: null)
global-variable-exists($name, $module: null) //=> boolean 
Returns whether a global variable named $name (without the $) exists.

If $module is null, this returns whether a variable named $name 
without a namespace exists. Otherwise, $module must be a string 
matching the namespace of a @use rule in the current file, 
in which case this returns whether that module has a variable named $name.
*/
@debug meta.global-variable-exists("var1"); // false
@debug meta.variable-exists("var1"); // false

$var1: value;
@debug meta.global-variable-exists("var1"); // true, 是全局的,
@debug meta.variable-exists("var1"); // true 全局也是一种范围

h1 {
	// $var2 is local.
	$var2: value;
	@debug meta.global-variable-exists("var2"); // false
	@debug meta.variable-exists("var2"); // true

	//function 不能作为 variable 使用来测试
	@debug meta.global-variable-exists("feature-supported", $module: "sys"); //false
	@debug meta.variable-exists("feature-supported"); //false
}

/*
meta.inspect($value)
inspect($value) //=> unquoted string 
Returns a string representation of $value.

Returns a representation of any Sass value, not just those that 
can be represented in CSS. As such, its return value is not 
guaranteed to be valid CSS.
*/
@debug meta.inspect(10px 20px 30px); // unquote("10px 20px 30px")
@debug meta.inspect(
	(
		"width": 200px,
	)
); // unquote('("width": 200px)')
@debug meta.inspect(null); // unquote("null")
@debug meta.inspect("Helvetica"); // unquote('"Helvetica"') , so is "Helvetica"

/*
meta.keywords($args)
keywords($args) //=> map 
Returns the keywords passed to a mixin or function that takes arbitrary 
arguments. The $args argument must be an argument list.

The keywords are returned as a map from argument names as unquoted strings 
(not including $) to the values of those arguments.
其实就是把有名参数列表转换为参数名到值得map.
无名参数被忽略
*/
@debug "-------------------------------";
@mixin syntax-colors($args...) {
	@debug meta.keywords($args);
	// (string: #080, comment: #800, variable: #60b)

	@each $name, $color in meta.keywords($args) {
		pre span.stx-#{$name} {
			color: $color;
		}
	}
}
@include syntax-colors($string: #080, $comment: #800, $variable: #60b);
@include syntax-colors(#080, #800, $mimi: #60b); //map只有(mimi:#60b)

/*
meta.mixin-exists($name, $module: null)
mixin-exists($name, $module: null) //=> boolean 
Returns whether a mixin named $name exists.

If $module is null, this returns whether a mixin named $name 
without a namespace exists. Otherwise, $module must be a string 
matching the namespace of a @use rule in the current file, in 
which case this returns whether that module has a mixin named $name.
*/
@debug meta.mixin-exists("shadow-none"); // false
@mixin shadow-none {
	box-shadow: none;
}
@debug meta.mixin-exists("shadow-none"); // true

/*
meta.module-functions($module) //=> map 
Returns all the functions defined in a module, as a map from 
function names to function values.

The $module parameter must be a string matching the namespace 
of a @use rule in the current file.
*/
@debug meta.module-functions("sys"); //必须指定代表命名空间的字符串, null "" 均不行

/*
meta.module-variables($module) //=> map 
Returns all the variables defined in a module, as a map from 
variable names (without $) to the values of those variables.

The $module parameter must be a string matching the namespace 
of a @use rule in the current file.
*/
@debug meta.module-variables("math");

/*
meta.type-of($value)
type-of($value) //=> unquoted string 
Returns the type of $value.

This can return the following values:
number string color list map calculation bool null function arglist

New possible values may be added in the future. It may return 
either list or map for (), depending on whether or not it was 
returned by a map function.
*/
@debug meta.type-of(10px); // number
@debug meta.type-of(10px 20px 30px); // list
@debug meta.type-of(()); // list
//@debug meta.type-of(); //error: Missing argument $value.
